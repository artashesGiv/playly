function b(y, {
  locales: I,
  format: d
}, u, i) {
  const r = new Intl.NumberFormat(I, d).formatToParts(Number(y));
  u && r.unshift({ type: "prefix", value: u }), i && r.push({ type: "suffix", value: i });
  const p = [], a = [], s = [], c = [], f = {}, n = (e) => `${e}:${f[e] = (f[e] ?? -1) + 1}`;
  let g = "", m = !1, v = !1, o = 0;
  for (const e of r) {
    g += e.value;
    const t = e.type === "minusSign" || e.type === "plusSign" ? "sign" : e.type;
    switch (t) {
      case "integer":
        m = !0, a.push(
          ...e.value.split("").map((l) => ({ type: t, value: parseInt(l) }))
        );
        break;
      case "group":
        a.push({ type: t, value: e.value });
        break;
      case "decimal":
        v = !0, s.push({
          type: t,
          value: e.value,
          key: n(t),
          originalIndex: o++
        });
        break;
      case "fraction":
        s.push(
          ...e.value.split("").map((l) => ({
            type: t,
            value: parseInt(l),
            key: n(t),
            originalIndex: o++
          }))
        );
        break;
      default:
        (m || v ? c : p).push({
          type: t,
          value: e.value,
          key: n(t),
          originalIndex: o++
        });
    }
  }
  const h = [];
  for (let e = a.length - 1; e >= 0; e--) {
    const t = n(a[e].type);
    h.unshift({
      ...a[e],
      key: t,
      originalIndex: e
    });
  }
  return { pre: p, integer: h, fraction: s, post: c, formatted: g };
}
export {
  b as formatToParts
};
