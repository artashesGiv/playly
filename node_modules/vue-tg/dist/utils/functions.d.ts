interface HookObject<TArgs extends any[], TResult> {
    before?: (args: TArgs) => void;
    after?: (args: TArgs, result: TResult) => void;
}
export declare function wrapFunction<TFunction extends (...args: any[]) => any, TOmitReturn extends boolean = false>(fn: TFunction, options?: {
    hooks?: HookObject<Parameters<TFunction>, ReturnType<TFunction>>;
    omitReturn?: TOmitReturn;
}): (...args: Parameters<TFunction>) => TOmitReturn extends true ? void : ReturnType<TFunction>;
type Callback<T> = (data: T) => void;
export declare function promisify<T, A extends any[]>(func: (...args: [...A, Callback<T>]) => void): (...args: A) => Promise<T>;
type CallbackWithNoData = () => void;
export declare function promisifyWithNoData<A extends any[]>(func: (...args: [...A, CallbackWithNoData]) => void): (...args: A) => Promise<void>;
type CallbackWithError<T> = (err: string | null, data: T | null) => void;
export declare function promisifyWithError<T, A extends any[]>(func: (...args: [...A, CallbackWithError<T>]) => void): (...args: A) => Promise<T>;
type CallbackWithMultipleData<T extends any[]> = (...data: T) => void;
export declare function promisifyWithDataObject<T extends any[], R extends Record<string, any>, A extends any[]>(func: (...args: [...A, CallbackWithMultipleData<T>]) => void, mapToObject: (...data: T) => R): (...args: A) => Promise<R>;
export {};
